# Release date 2026-02-16
#
# INSTALLATION GUIDE: https://github.com/mkaiser/Sungrow-SHx-Inverter-Modbus-Home-Assistant/blob/main/doc/installation.md
#
# MIGRATING GUIDE from version earlier than 2026 of modbus_sungrow.yaml to this version.
# see https://github.com/mkaiser/Sungrow-SHx-Inverter-Modbus-Home-Assistant/blob/main/doc/migration_guide.md

modbus:
  - name: &sg_hub_name SungrowSHx
    type: tcp
    host: !secret sungrow_modbus_host_ip
    port: !secret sungrow_modbus_port
    delay: 15 # delay 5 second after connecting
    timeout: 30 # timeout while waiting for a response before flodding the log with errors
    message_wait_milliseconds: !secret sungrow_modbus_wait_milliseconds # delay between messages, depending on inverter connection

    sensors:
      - name: Sungrow Version 1
        # first part of firmware string
        # SAPPHIRE-H_01011.95.12SAPPHIRE-H_03011.95.12SUBCTL-S_04011.01.01
        # --> SAPPHIRE-H_01011.95.12
        unique_id: sg_version_1
        device_address: !secret sungrow_modbus_device_address
        address: 2581 # reg 2582
        input_type: input
        data_type: string
        count: 11
        scan_interval: &scan_interval_slowest 600

      - name: Sungrow Version 2
        # second part of firmware string
        # SAPPHIRE-H_01011.95.12SAPPHIRE-H_03011.95.12SUBCTL-S_04011.01.01
        # --> SAPPHIRE-H_03011.95.12
        unique_id: sg_version_2
        device_address: !secret sungrow_modbus_device_address
        address: 2596
        input_type: input
        data_type: string
        count: 11
        scan_interval: *scan_interval_slowest

      - name: Sungrow Version 3
        # third part of firmware string
        # SAPPHIRE-H_01011.95.12SAPPHIRE-H_03011.95.12SUBCTL-S_04011.01.01
        # --> SUBCTL-S_04011.01.01
        unique_id: sg_version_3
        device_address: !secret sungrow_modbus_device_address
        address: 2612
        input_type: input
        data_type: string
        count: 11
        scan_interval: *scan_interval_slowest

      - name: Sungrow Version 4 (Sungrow Battery)
        # TODO: cannot test, have no sungrow battery
        # fourth part of firmware string (only for sungrow batteries)
        # SAPPHIRE-H_01011.95.12SAPPHIRE-H_03011.95.12SUBCTL-S_04011.01.01 - XXXX
        # --> XXXX
        unique_id: sg_version_4_battery
        device_address: !secret sungrow_modbus_device_address
        address: 2628
        input_type: input
        data_type: string
        count: 11
        scan_interval: *scan_interval_slowest

      - name: Sungrow Protocol Version
        unique_id: sg_protocol_version
        device_address: !secret sungrow_modbus_device_address
        address: 4951 # reg 5952-4953
        input_type: input
        data_type: uint32
        swap: word
        scan_interval: *scan_interval_slowest

      - name: Sungrow Arm Software
        unique_id: sg_arm_software
        device_address: !secret sungrow_modbus_device_address
        address: 4953 # reg 4954-4968, 15 registers
        input_type: input
        data_type: string
        count: 15
        scan_interval: *scan_interval_slowest

      - name: Sungrow DSP Software
        unique_id: sg_dsp_software
        device_address: !secret sungrow_modbus_device_address
        address: 4968 # reg 4969-4983, 15 registers
        input_type: input
        data_type: string
        count: 15
        scan_interval: *scan_interval_slowest

      - name: Sungrow inverter serial
        unique_id: sg_inverter_serial
        device_address: !secret sungrow_modbus_device_address
        address: 4989 # reg 4990- 4999, 10 registers
        input_type: input
        data_type: string
        count: 10
        scan_interval: *scan_interval_slowest

      # for Sungrow batteries only
      #      - name: Sungrow battery serial
      #        unique_id: sg_battery_serial
      #        device_address: !secret sungrow_modbus_sbr_device_address
      #        address: 10710 # reg 10711
      #        input_type: input
      #        data_type: string
      #        count: 10
      #        scan_interval: 86400

      - name: Sungrow device type code
        unique_id: sg_dev_code
        device_address: !secret sungrow_modbus_device_address
        address: 4999 # reg 5000
        input_type: input
        data_type: uint16
        scan_interval: *scan_interval_slowest

      - name: Inverter rated output
        unique_id: sg_inverter_rated_output
        device_address: !secret sungrow_modbus_device_address
        address: 5000 # reg 5001
        input_type: input
        data_type: uint16
        unit_of_measurement: "W"
        device_class: power
        state_class: measurement
        scale: 100
        scan_interval: *scan_interval_slowest

      - name: Daily PV generation & battery discharge
        unique_id: sg_daily_pv_gen_battery_discharge
        device_address: !secret sungrow_modbus_device_address
        address: 5002 # reg 5003
        input_type: input
        data_type: uint16
        precision: 1
        unit_of_measurement: kWh
        device_class: energy
        state_class: total_increasing
        scale: 0.1
        scan_interval: *scan_interval_slowest

      - name: Total PV generation & battery discharge
        unique_id: sg_total_pv_gen_battery_discharge
        device_address: !secret sungrow_modbus_device_address
        address: 5003 # reg 5004
        input_type: input
        data_type: uint32
        swap: word
        unit_of_measurement: kWh
        precision: 1
        device_class: energy
        state_class: total
        scale: 0.1
        scan_interval: *scan_interval_slowest

      - name: Inverter temperature
        unique_id: sg_inverter_temperature
        device_address: !secret sungrow_modbus_device_address
        address: 5007 # reg 5008
        input_type: input
        data_type: int16
        precision: 1
        unit_of_measurement: °C
        device_class: temperature
        state_class: measurement
        scale: 0.1
        scan_interval: &scan_interval_medium 60

      - name: MPPT1 voltage
        unique_id: sg_mppt1_voltage
        device_address: !secret sungrow_modbus_device_address
        address: 5010 # reg 5011
        input_type: input
        data_type: uint16
        precision: 1
        unit_of_measurement: V
        device_class: voltage
        state_class: measurement
        scale: 0.1
        scan_interval: &scan_interval_fast 10

      - name: MPPT1 current
        unique_id: sg_mppt1_current
        device_address: !secret sungrow_modbus_device_address
        address: 5011 # reg 5012
        input_type: input
        data_type: uint16
        precision: 1
        unit_of_measurement: A
        device_class: current
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_fast

      - name: MPPT2 voltage
        unique_id: sg_mppt2_voltage
        device_address: !secret sungrow_modbus_device_address
        address: 5012 # reg 5013
        input_type: input
        data_type: uint16
        precision: 1
        unit_of_measurement: V
        device_class: voltage
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_fast

      - name: MPPT2 current
        unique_id: sg_mppt2_current
        device_address: !secret sungrow_modbus_device_address
        address: 5013 # reg 5014
        input_type: input
        data_type: uint16
        precision: 1
        unit_of_measurement: A
        device_class: current
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_fast

      # only for SH*T inverters with 3 MPPTs
      # NOTE that mppt3 registers read on a SH10RT as 0xFFFF
      # Therefore adding the nan_value here. This causes HA to render the sensor as 'unavailable' instead of '6553.5 V'
      - name: MPPT3 voltage
        unique_id: sg_mppt3_voltage
        device_address: !secret sungrow_modbus_device_address
        address: 5014 # reg 5015
        input_type: input
        data_type: uint16
        nan_value: 0xFFFF
        precision: 1
        unit_of_measurement: V
        device_class: voltage
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_fast

      # only for SH*T inverters with 3 MPPTs
      # NOTE that mppt3 registers read on a SH10RT as 0xFFFF
      # Therefore adding the nan_value here. This causes HA to render the sensor as 'unavailable' instead of '6553.5 V'
      - name: MPPT3 current
        unique_id: sg_mppt3_current
        device_address: !secret sungrow_modbus_device_address
        address: 5015 # reg 5016
        input_type: input
        data_type: uint16
        nan_value: 0xFFFF
        precision: 1
        unit_of_measurement: A
        device_class: current
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_fast

      - name: Total DC power
        unique_id: sg_total_dc_power
        device_address: !secret sungrow_modbus_device_address
        address: 5016 # reg 5017
        input_type: input
        data_type: uint32
        swap: word
        precision: 0
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        scale: 1
        scan_interval: *scan_interval_fast

      - name: Phase A voltage
        unique_id: sg_phase_a_voltage
        device_address: !secret sungrow_modbus_device_address
        address: 5018 # reg: 5019
        input_type: input
        data_type: uint16
        precision: 1
        unit_of_measurement: V
        device_class: voltage
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_fast

      - name: Phase B voltage
        unique_id: sg_phase_b_voltage
        device_address: !secret sungrow_modbus_device_address
        address: 5019 # reg: 5020
        input_type: input
        data_type: uint16
        precision: 1
        unit_of_measurement: V
        device_class: voltage
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_fast

      - name: Phase C voltage
        unique_id: sg_phase_c_voltage
        device_address: !secret sungrow_modbus_device_address
        address: 5020 # reg: 5021
        input_type: input
        data_type: uint16
        precision: 1
        unit_of_measurement: V
        device_class: voltage
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_fast

      - name: Reactive power
        unique_id: sg_reactive_power
        device_address: !secret sungrow_modbus_device_address
        address: 5032 # reg 5033
        input_type: input
        data_type: int32
        swap: word
        precision: 0
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        scale: 1
        scan_interval: *scan_interval_fast

      - name: Power factor
        unique_id: sg_power_factor
        device_address: !secret sungrow_modbus_device_address
        address: 5034 # reg 5035
        input_type: input
        data_type: int16
        precision: 3
        unit_of_measurement: "%"
        device_class: power_factor
        state_class: measurement
        scale: 0.001
        scan_interval: *scan_interval_fast

      # only for inverters with 4 MPPTs (SH8|10RS)
      # NOTE that mppt4 registers read on a SH10RT as 0xFFFF, using nan_value to render the value unavailable
      - name: MPPT4 voltage
        unique_id: sg_mppt4_voltage
        device_address: !secret sungrow_modbus_device_address
        address: 5114 # reg 5115
        input_type: input
        data_type: uint16
        nan_value: 0xFFFF
        precision: 1
        unit_of_measurement: V
        device_class: voltage
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_fast

      # only for inverters with 4 MPPTs (SH8|10RS)
      # NOTE that mppt4 registers read on a SH10RT as 0xFFFF, using nan_value to render the value unavailable
      - name: MPPT4 current
        unique_id: sg_mppt4_current
        device_address: !secret sungrow_modbus_device_address
        address: 5115 # reg 5116
        input_type: input
        data_type: uint16
        nan_value: 0xFFFF
        precision: 1
        unit_of_measurement: A
        device_class: current
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_fast

      # NOTE: In datasheet (1.1.11) it is recommended to use this register instead of 13022
      # negative: Battery charging
      # positive: Battery discharging
      - name: Battery power
        unique_id: sg_battery_power
        device_address: !secret sungrow_modbus_device_address
        address: 5213 # reg 5214-5215
        input_type: input
        data_type: int32
        swap: word
        precision: 0
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        scale: 1
        scan_interval: *scan_interval_fast

      - name: Grid frequency
        unique_id: sg_grid_frequency
        device_address: !secret sungrow_modbus_device_address
        address: 5241 # reg 5242
        input_type: input
        data_type: uint16
        precision: 2
        unit_of_measurement: "Hz"
        device_class: frequency
        state_class: measurement
        scale: 0.01
        scan_interval: *scan_interval_fast

        # modbus spec: Only valid when the inverter is directly connected to the smart energy meter. (See note 1);
        # ＞ 0 buy from grid; ＜ 0 sell to grid;
      - name: Meter active power
        unique_id: sg_meter_active_power
        device_address: !secret sungrow_modbus_device_address
        address: 5600 # reg 5601
        input_type: input
        data_type: int32
        swap: word
        nan_value: 0x7FFFFFFF
        precision: 0
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        scale: 1
        scan_interval: *scan_interval_fast

        # modbus spec: Only valid when the inverter is directly connected to the smart energy meter. (See note 1);
        # ＞ 0 buy from grid; ＜ 0 sell to grid;
      - name: Meter phase A active power
        unique_id: sg_meter_phase_a_active_power
        device_address: !secret sungrow_modbus_device_address
        address: 5602 # reg 5603
        input_type: input
        data_type: int32
        swap: word
        nan_value: 0x7FFFFFFF
        precision: 0
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        scale: 1
        scan_interval: *scan_interval_fast

        # modbus spec: Only valid when the inverter is directly connected to the smart energy meter. (See note 1);
        # ＞ 0 buy from grid; ＜ 0 sell to grid;
      - name: Meter phase B active power
        unique_id: sg_meter_phase_b_active_power
        device_address: !secret sungrow_modbus_device_address
        address: 5604 # reg 5605
        input_type: input
        data_type: int32
        swap: word
        nan_value: 0x7FFFFFFF
        precision: 0
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        scale: 1
        scan_interval: *scan_interval_fast

        # modbus spec: Only valid when the inverter is directly connected to the smart energy meter. (See note 1);
        # ＞ 0 buy from grid; ＜ 0 sell to grid;
      - name: Meter phase C active power
        unique_id: sg_meter_phase_c_active_power
        device_address: !secret sungrow_modbus_device_address
        address: 5606 # reg 5607
        input_type: input
        data_type: int32
        swap: word
        nan_value: 0x7FFFFFFF
        precision: 0
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        scale: 1
        scan_interval: *scan_interval_fast

      - name: BDC rated power
        unique_id: sg_bdc_rated_power
        device_address: !secret sungrow_modbus_device_address
        address: 5627 # reg 5628
        input_type: input
        data_type: uint16
        unit_of_measurement: "W"
        device_class: power
        state_class: measurement
        scale: 100
        scan_interval: *scan_interval_slowest

      # NOTE: In datasheet (1.1.11) it is recommended to use Battery current register 5631 instead of 13021
      - name: Battery current
        unique_id: sg_battery_current
        device_address: !secret sungrow_modbus_device_address
        address: 5630 # reg 5631
        input_type: input
        data_type: int16
        precision: 1
        unit_of_measurement: A
        state_class: measurement
        device_class: current
        scale: 0.1
        scan_interval: *scan_interval_fast

      - name: BMS max. charging current
        unique_id: sg_bms_max_charging_current
        device_address: !secret sungrow_modbus_device_address
        address: 5634 # reg 5635
        input_type: input
        data_type: uint16
        precision: 0
        unit_of_measurement: A
        device_class: current
        state_class: measurement
        scale: 1
        scan_interval: *scan_interval_slowest

      - name: BMS max. discharging current
        unique_id: sg_bms_max_discharging_current
        device_address: !secret sungrow_modbus_device_address
        address: 5635 # reg 5636
        input_type: input
        data_type: uint16
        precision: 0
        unit_of_measurement: A
        device_class: current
        state_class: measurement
        scale: 1
        scan_interval: *scan_interval_slowest

      - name: Battery capacity high precision # as in TI_20240924_Communication Protocol of Residential Hybrid Inverter-V1.1.5
        unique_id: uid_battery_capacity_high_precision
        device_address: !secret sungrow_modbus_device_address
        address: 5638 # reg 5639
        input_type: input
        data_type: uint16
        precision: 2
        unit_of_measurement: kWh
        device_class: energy_storage
        scale: 0.01
        scan_interval: *scan_interval_slowest

      - name: Backup phase A power
        unique_id: sg_backup_phase_a_power
        device_address: !secret sungrow_modbus_device_address
        address: 5722 # reg 5723
        input_type: input
        data_type: int16
        precision: 0
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        scale: 1
        scan_interval: *scan_interval_fast

      - name: Backup phase B power
        unique_id: sg_backup_phase_b_power
        device_address: !secret sungrow_modbus_device_address
        address: 5723 # reg 5724
        input_type: input
        data_type: int16
        precision: 0
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        scale: 1
        scan_interval: *scan_interval_fast

      - name: Backup phase C power
        unique_id: sg_backup_phase_c_power
        device_address: !secret sungrow_modbus_device_address
        address: 5724 # reg 5725
        input_type: input
        data_type: int16
        precision: 0
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        scale: 1
        scan_interval: *scan_interval_fast

      - name: Total backup power
        device_address: !secret sungrow_modbus_device_address
        unique_id: sg_total_backup_power
        address: 5725 # reg 5726
        input_type: input
        data_type: int32
        swap: word
        precision: 0
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        scale: 1
        scan_interval: *scan_interval_fast

      # https://www.photovoltaikforum.com/thread/166134-daten-lesen-vom-sungrow-wechselrichtern-modbus/?postID=3324464#post3324464
      - name: Meter phase A voltage
        unique_id: sg_meter_phase_a_voltage
        device_address: !secret sungrow_modbus_device_address
        address: 5740 # reg 5741
        input_type: input
        data_type: int16
        precision: 1
        unit_of_measurement: V
        device_class: voltage
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_fast

      - name: Meter phase B voltage
        unique_id: sg_meter_phase_b_voltage
        device_address: !secret sungrow_modbus_device_address
        address: 5741 # reg 5742
        input_type: input
        data_type: int16
        precision: 1
        unit_of_measurement: V
        device_class: voltage
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_fast

      - name: Meter phase C voltage
        unique_id: sg_meter_phase_c_voltage
        device_address: !secret sungrow_modbus_device_address
        address: 5742 # reg 5743
        input_type: input
        data_type: int16
        precision: 1
        unit_of_measurement: V
        device_class: voltage
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_fast

      - name: Meter phase A current
        unique_id: sg_meter_phase_a_current
        device_address: !secret sungrow_modbus_device_address
        address: 5743 # reg 5744
        input_type: input
        data_type: uint16
        precision: 2
        unit_of_measurement: A
        device_class: current
        state_class: measurement
        scale: 0.01
        scan_interval: *scan_interval_fast

      - name: Meter phase B current
        unique_id: sg_meter_phase_b_current
        device_address: !secret sungrow_modbus_device_address
        address: 5744 # reg 5745
        input_type: input
        data_type: uint16
        precision: 2
        unit_of_measurement: A
        device_class: current
        state_class: measurement
        scale: 0.01
        scan_interval: *scan_interval_fast

      - name: Meter phase C current
        unique_id: sg_meter_phase_c_current
        device_address: !secret sungrow_modbus_device_address
        address: 5745 # reg 5746
        input_type: input
        data_type: uint16
        precision: 2
        unit_of_measurement: A
        device_class: current
        state_class: measurement
        scale: 0.01
        scan_interval: *scan_interval_fast

      # NOTE: in old modbus doc version this was called "system state"
      # but has been renamed to "running state"
      - name: Running state raw
        unique_id: uid_sg_running_state_raw
        device_address: !secret sungrow_modbus_device_address
        address: &sg_reg_running_state 12999 # reg 13000
        input_type: input
        data_type: uint16
        precision: 0
        scale: 1
        state_class: measurement
        scan_interval: &scan_interval_realtime 5

      # NOTE: In old modbus doc versions this was called "running state"
      # but has been renamed to "power flow status"
      # template binary sensors are used to determine their states based on this value
      - name: Power Flow Status
        unique_id: uid_power_flow_status
        device_address: !secret sungrow_modbus_device_address
        address: 13000 # reg 13001
        input_type: input
        data_type: uint16
        precision: 0
        state_class: measurement
        scale: 1
        scan_interval: *scan_interval_realtime

      - name: Daily PV generation
        unique_id: sg_daily_pv_generation
        device_address: !secret sungrow_modbus_device_address
        address: 13001 # reg 13002
        input_type: input
        data_type: uint16
        precision: 1
        unit_of_measurement: kWh
        device_class: energy
        state_class: total_increasing
        scale: 0.1
        scan_interval: *scan_interval_slowest

      - name: Total PV generation
        unique_id: sg_total_pv_generation
        device_address: !secret sungrow_modbus_device_address
        address: 13002 # reg 13003
        input_type: input
        data_type: uint32
        swap: word
        precision: 1
        unit_of_measurement: kWh
        device_class: energy
        state_class: total
        scale: 0.1
        scan_interval: *scan_interval_slowest

      - name: Daily exported energy from PV
        unique_id: sg_daily_exported_energy_from_PV
        device_address: !secret sungrow_modbus_device_address
        address: 13004 # reg 13005
        input_type: input
        data_type: uint16
        precision: 1
        unit_of_measurement: kWh
        device_class: energy
        state_class: total_increasing
        scale: 0.1
        scan_interval: *scan_interval_slowest

      - name: Total exported energy from PV
        unique_id: sg_total_exported_energy_from_pv
        device_address: !secret sungrow_modbus_device_address
        address: 13005 # reg 13006
        input_type: input
        data_type: uint32
        swap: word
        precision: 1
        unit_of_measurement: kWh
        device_class: energy
        state_class: total
        scale: 0.1
        scan_interval: *scan_interval_slowest

      - name: Load power
        unique_id: sg_load_power
        device_address: !secret sungrow_modbus_device_address
        address: 13007 # reg 13008
        input_type: input
        data_type: int32
        swap: word
        precision: 0
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        scale: 1
        scan_interval: *scan_interval_realtime

      # this value returns a positive value when exporting and a negative value when importing power
      - name: Export power raw
        unique_id: sg_battery_export_power_raw
        device_address: !secret sungrow_modbus_device_address
        address: 13009 # reg 13010
        input_type: input
        data_type: int32
        swap: word
        precision: 0
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        scale: 1
        scan_interval: *scan_interval_fast

      - name: Daily battery charge from PV
        unique_id: sg_daily_battery_charge_from_pv
        device_address: !secret sungrow_modbus_device_address
        address: 13011 # reg 13012
        input_type: input
        data_type: uint16
        precision: 1
        unit_of_measurement: kWh
        device_class: energy
        state_class: total_increasing
        scale: 0.1
        scan_interval: *scan_interval_slowest

      - name: Total battery charge from PV
        unique_id: sg_total_battery_charge_from_pv
        device_address: !secret sungrow_modbus_device_address
        address: 13012 # reg 13013
        input_type: input
        data_type: uint32
        swap: word
        precision: 1
        unit_of_measurement: kWh
        device_class: energy
        state_class: total
        scale: 0.1
        scan_interval: *scan_interval_slowest

      - name: Daily direct energy consumption
        unique_id: sg_daily_direct_energy_consumption
        device_address: !secret sungrow_modbus_device_address
        address: 13016 # reg 13017
        input_type: input
        data_type: uint16
        precision: 1
        unit_of_measurement: kWh
        device_class: energy
        state_class: total_increasing
        scale: 0.1
        scan_interval: *scan_interval_slowest

      - name: Total direct energy consumption
        unique_id: sg_total_direct_energy_consumption
        device_address: !secret sungrow_modbus_device_address
        address: 13017 # reg 13018
        input_type: input
        data_type: uint32
        swap: word
        precision: 1
        unit_of_measurement: kWh
        device_class: energy
        state_class: total
        scale: 0.1
        scan_interval: *scan_interval_slowest

      - name: Battery voltage
        unique_id: sg_battery_voltage
        device_address: !secret sungrow_modbus_device_address
        address: 13019 # reg 13020
        input_type: input
        data_type: uint16
        precision: 1
        unit_of_measurement: V
        device_class: voltage
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_fast

      # NOTE: 2025-12-12. This sensor was replaced by register 5631 as recommended in the datasheet
      #  datasheet states that this value is unsigned, but it is actually signed:
      # https://github.com/mkaiser/Sungrow-SHx-Inverter-Modbus-Home-Assistant/issues/304
      # - name: Battery current
      #   unique_id: sg_battery_current
      #   device_address: !secret sungrow_modbus_device_address
      #   address: 13020 # reg 13021
      #   input_type: input
      #   data_type: int16
      #   precision: 1
      #   unit_of_measurement: A
      #   state_class: measurement
      #   device_class: current
      #   scale: 0.1
      #   scan_interval: *scan_interval_fast

      # NOTE: 2025-12-12: substituted this register by reg 5214 as recommended in the datasheet
      # old firmware ( before october 2024): always positive battery power
      # use binary_sensor.battery_charging | discharging to retrieve the direction of the energy flow
      # new firmware: positive if charging and negative if discharging
      # with new firmware installed we could use this raw value directly as signed battery power
      # to support both firmwares we use the template sensor "signed battery power"
      # - name: Battery power raw
      #   unique_id: sg_battery_power_raw
      #   device_address: !secret sungrow_modbus_device_address
      #   address: 13021 # reg 13022
      #   input_type: input
      #   data_type: int16 #updated to signed int, see github issue #406
      #   precision: 0
      #   unit_of_measurement: W
      #   device_class: power
      #   state_class: measurement
      #   scale: 1
      #   scan_interval: *scan_interval_fast

      # 0..100%  |  min_soc..max_soc
      - name: Battery level
        unique_id: sg_battery_level
        device_address: !secret sungrow_modbus_device_address
        address: 13022 # reg 13023
        input_type: input
        data_type: uint16
        precision: 1
        unit_of_measurement: "%"
        device_class: battery
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_medium

      # 0..100% calculated internally by the BMS load balancing
      - name: Battery state of health
        unique_id: sg_battery_state_of_health
        device_address: !secret sungrow_modbus_device_address
        address: 13023 # reg 13024
        input_type: input
        data_type: uint16
        precision: 0
        unit_of_measurement: "%"
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_slowest

      - name: Battery temperature
        unique_id: sg_battery_temperature
        device_address: !secret sungrow_modbus_device_address
        address: 13024 # reg 13025
        input_type: input
        data_type: int16
        precision: 1
        unit_of_measurement: °C
        device_class: temperature
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_medium

      - name: Daily battery discharge
        unique_id: sg_daily_battery_discharge
        device_address: !secret sungrow_modbus_device_address
        address: 13025 # reg 13026
        input_type: input
        data_type: uint16
        precision: 1
        unit_of_measurement: kWh
        device_class: energy
        state_class: total_increasing
        scale: 0.1
        scan_interval: *scan_interval_slowest

      - name: Total battery discharge
        unique_id: sg_total_battery_discharge
        device_address: !secret sungrow_modbus_device_address
        address: 13026 # reg 13027
        input_type: input
        data_type: uint32
        swap: word
        precision: 1
        unit_of_measurement: kWh
        device_class: energy
        state_class: total
        scale: 0.1
        scan_interval: *scan_interval_slowest

      - name: Phase A current
        unique_id: sg_phase_a_current
        device_address: !secret sungrow_modbus_device_address
        address: 13030 # reg 13031
        input_type: input
        data_type: int16
        precision: 1
        unit_of_measurement: A
        device_class: current
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_fast

      - name: Phase B current
        unique_id: sg_phase_b_current
        device_address: !secret sungrow_modbus_device_address
        address: 13031 # reg 13032
        input_type: input
        data_type: int16
        precision: 1
        unit_of_measurement: A
        device_class: current
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_fast

      - name: Phase C current
        unique_id: sg_phase_c_current
        device_address: !secret sungrow_modbus_device_address
        address: 13032 # reg 13033
        input_type: input
        data_type: int16
        precision: 1
        unit_of_measurement: A
        device_class: current
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_fast

      - name: Total active power
        unique_id: sg_total_active_power
        device_address: !secret sungrow_modbus_device_address
        address: 13033 # reg 13034
        input_type: input
        data_type: int32
        swap: word
        precision: 0
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        scale: 1
        scan_interval: *scan_interval_fast

      - name: Daily imported energy
        unique_id: sg_daily_imported_energy
        device_address: !secret sungrow_modbus_device_address
        address: 13035 # reg 13036
        input_type: input
        data_type: uint16
        precision: 1
        unit_of_measurement: kWh
        device_class: energy
        state_class: total_increasing
        scale: 0.1
        scan_interval: *scan_interval_slowest

      - name: Total imported energy
        unique_id: sg_total_imported_energy
        device_address: !secret sungrow_modbus_device_address
        address: 13036 # reg 13037
        input_type: input
        data_type: uint32
        swap: word
        precision: 1
        unit_of_measurement: kWh
        device_class: energy
        state_class: total
        scale: 0.1
        scan_interval: *scan_interval_slowest

      - name: Daily battery charge
        unique_id: sg_daily_battery_charge
        device_address: !secret sungrow_modbus_device_address
        address: 13039 # reg 13040
        input_type: input
        data_type: uint16
        precision: 1
        unit_of_measurement: kWh
        device_class: energy
        state_class: total_increasing
        scale: 0.1
        scan_interval: *scan_interval_slowest

      - name: Total battery charge
        unique_id: sg_total_battery_charge
        device_address: !secret sungrow_modbus_device_address
        address: 13040 # reg 13041
        input_type: input
        data_type: uint32
        swap: word
        precision: 1
        unit_of_measurement: kWh
        device_class: energy
        state_class: total
        scale: 0.1
        scan_interval: *scan_interval_slowest

      - name: Daily exported energy
        unique_id: sg_daily_exported_energy
        device_address: !secret sungrow_modbus_device_address
        address: 13044 # reg 13045
        input_type: input
        data_type: uint16
        precision: 1
        unit_of_measurement: kWh
        device_class: energy
        state_class: total_increasing
        scale: 0.1
        scan_interval: *scan_interval_slowest

      - name: Total exported energy
        unique_id: sg_total_exported_energy
        device_address: !secret sungrow_modbus_device_address
        address: 13045 # reg 13046
        input_type: input
        data_type: uint32
        swap: word
        precision: 1
        unit_of_measurement: kWh
        device_class: energy
        state_class: total
        scale: 0.1
        scan_interval: *scan_interval_slowest

      #####################
      # modbus holding registers
      #####################
      - name: Load adjustment mode selection raw
        unique_id: sg_load_adjustment_mode_selection_raw
        device_address: !secret sungrow_modbus_device_address
        address: &sg_reg_load_adjustment_mode_selection 13001 # reg 13002
        input_type: holding
        data_type: uint16
        state_class: measurement
        scan_interval: *scan_interval_fast

      - name: Load adjustment mode enable raw
        unique_id: sg_load_adjustment_mode_enable_raw
        device_address: !secret sungrow_modbus_device_address
        address: &sg_reg_load_adjustment_mode_enable 13010 # reg 13011
        input_type: holding
        data_type: uint16
        state_class: measurement
        scan_interval: *scan_interval_fast

      # BUG: 2026-01-10. Deactivated for now, see issue #643
      # https://github.com/mkaiser/Sungrow-SHx-Inverter-Modbus-Home-Assistant/issues/643
      # TODO test. Does this control, if the standby goes into standby at night?
      # Does forced charge prevent this or not?
      # see https://github.com/mkaiser/Sungrow-SHx-Inverter-Modbus-Home-Assistant/issues/444#issuecomment-3471705119
      # - name: Forced startup under low soc standby raw
      #   unique_id: sg_forced_startup_under_low_soc_standby_raw
      #   device_address: !secret sungrow_modbus_device_address
      #   address: &sg_reg_forced_startup_low_soc 13016 # reg 13017
      #   input_type: holding
      #   data_type: uint16
      #   state_class: measurement
      #   scan_interval: *scan_interval_fast

      - name: EMS mode selection raw
        unique_id: sg_ems_mode_selection_raw
        device_address: !secret sungrow_modbus_device_address
        address: &sg_reg_ems_mode_selection 13049 # reg 13050
        input_type: holding
        data_type: uint16
        state_class: measurement
        scan_interval: *scan_interval_fast

      - name: Battery forced charge discharge cmd raw
        unique_id: sg_battery_forced_charge_discharge_cmd_raw
        device_address: !secret sungrow_modbus_device_address
        address: &sg_reg_forced_charge_discharge_cmd_raw 13050 # reg 13051
        input_type: holding
        data_type: uint16
        precision: 0
        state_class: measurement
        scan_interval: *scan_interval_fast

      - name: Battery forced charge discharge power
        unique_id: sg_battery_forced_charge_discharge_power
        device_address: !secret sungrow_modbus_device_address
        address: &sg_reg_battery_forced_charge_discharge_power 13051 # reg 13052
        input_type: holding
        data_type: uint16
        precision: 0
        # datasheet says:
        # 0 to 5000 W for SH*K-*
        # 0 to 100 % for SH*.0RT
        # for my SH10RT it is set in Watt, not in %
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        scan_interval: *scan_interval_fast

      - name: Battery max SoC
        unique_id: uid_sg_battery_max_soc
        device_address: !secret sungrow_modbus_device_address
        address: &sg_reg_max_soc 13057 # reg 13058
        input_type: holding
        data_type: uint16
        precision: 1
        unit_of_measurement: "%"
        device_class: battery
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_fast

      - name: Battery min SoC
        unique_id: uid_sg_battery_min_soc
        device_address: !secret sungrow_modbus_device_address
        address: &sg_reg_min_soc 13058 # reg 13059
        input_type: holding
        data_type: uint16
        precision: 1
        unit_of_measurement: "%"
        device_class: battery
        state_class: measurement
        scale: 0.1
        scan_interval: *scan_interval_fast

      # in the documentation this is called "feed-in power limit"
      - name: Export power limit
        unique_id: sg_export_power_limit
        device_address: !secret sungrow_modbus_device_address
        address: &sg_reg_export_power_limit 13073 # reg 13074
        input_type: holding
        data_type: uint16
        precision: 0
        unit_of_measurement: "W"
        device_class: power
        state_class: measurement
        scale: 1
        scan_interval: *scan_interval_fast

      # called "Off-grid option" in spec
      - name: Backup mode raw
        unique_id: sg_backup_mode_raw
        device_address: !secret sungrow_modbus_device_address
        address: &sg_reg_backup_mode 13074 # reg 13075
        input_type: holding
        data_type: uint16
        state_class: measurement
        scan_interval: *scan_interval_fast

      # called "Feed-in limitation" in spec
      - name: Export power limit mode raw
        unique_id: sg_export_power_limit_mode_raw
        device_address: !secret sungrow_modbus_device_address
        address: &sg_reg_export_power_limit_mode 13086 # reg 13087
        input_type: holding
        data_type: uint16
        precision: 0
        state_class: measurement
        scan_interval: *scan_interval_fast

      # TODO test and implement from theunknown86
      # TODO datasheet name: Feed-in Limitation Ratio
      # https://github.com/mkaiser/Sungrow-SHx-Inverter-Modbus-Home-Assistant/issues/554#issuecomment-3170420960
      # MG5-6RL is not supported.
      # 0xAA: Enable
      # 0x55: Disable
      - name: Active power limitation raw
        unique_id: sg_active_power_limitation_raw
        device_address: !secret sungrow_modbus_device_address
        address: &reg_active_power_limitation_raw 13088 # reg 13089
        input_type: holding
        data_type: uint16
        scan_interval: *scan_interval_fast
        state_class: measurement

      # MG5-6RL is not supported.
      # 0-1000
      - name: Active power limitation ratio raw
        unique_id: sg_active_power_limitation_ratio_raw
        device_address: !secret sungrow_modbus_device_address
        address: &reg_active_power_limitation_ratio_raw 13089 # reg 13090
        input_type: holding
        data_type: uint16
        scan_interval: *scan_interval_fast
        state_class: measurement
        scale: 0.1
        unit_of_measurement: "%"

      - name: Battery reserved SoC for backup
        unique_id: sg_battery_reserved_soc_for_backup
        device_address: !secret sungrow_modbus_device_address
        address: &sg_reg_reserved_soc_backup 13099 # reg 13100
        input_type: holding
        data_type: uint16
        unit_of_measurement: "%"
        device_class: battery
        state_class: measurement
        scale: 1
        scan_interval: *scan_interval_fast

      # Inverter Firmware version from register 13250 to 13264 as UTF8 string
      # NOTE: SH3.0-10RS and MG5-6RL are NOT supported
      - name: Inverter Firmware Version
        unique_id: sg_inverter_firmware_version
        device_address: !secret sungrow_modbus_device_address
        address: 13249 # reg 13250 - 13264, 15 register
        input_type: input
        data_type: string
        count: 15
        scan_interval: *scan_interval_slowest

      # Communication Module Firmware version from register 13265 to 13279 as UTF8 string
      # NOTE: SH3.0-10RS and MG5-6RL are NOT supported
      - name: Communication Module Firmware Version
        unique_id: sg_communication_module_firmware_version
        device_address: !secret sungrow_modbus_device_address
        address: 13264 # reg 13265 - 13279, 15 register
        input_type: input
        data_type: string
        count: 15
        scan_interval: *scan_interval_fast

      # Battery Firmware version from register 13280 to 13279 as UTF8 string
      # NOTE: SH3.0-10RS and MG5-6RL are NOT supported
      - name: Battery Firmware Version
        unique_id: sg_battery_firmware_version
        device_address: !secret sungrow_modbus_device_address
        address: 13279 # reg 13280 - 13279, 15 register
        input_type: input
        data_type: string
        count: 15
        scan_interval: *scan_interval_slowest

      # NOTE: 2025-12-10
      # from 'theunknown' too, but can't find this in the datasheet
      # https://github.com/mkaiser/Sungrow-SHx-Inverter-Modbus-Home-Assistant/issues/554#issuecomment-3170420960
      - name: APL shutdown at zero raw
        unique_id: sg_apl_shutdown_on_zero_raw
        device_address: !secret sungrow_modbus_device_address
        address: &sg_reg_apl_shutdown_on_zero_raw 31212 # reg 31213
        input_type: holding
        data_type: uint16
        state_class: measurement
        scan_interval: *scan_interval_fast

      # NOTE: datasheet (1.1.11) states 0.01kW as unit (scale=100)
      - name: Battery max charge power
        unique_id: sg_battery_max_charge_power
        device_address: !secret sungrow_modbus_device_address
        address: &sg_reg_battery_max_charge_power 33046 # reg 33047
        input_type: holding
        data_type: uint16
        precision: 0
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        scale: 10
        scan_interval: *scan_interval_fast

      # NOTE: datasheet (1.1.11) states 0.01kW as unit (scale=100)
      - name: Battery max discharge power
        unique_id: sg_battery_max_discharge_power
        device_address: !secret sungrow_modbus_device_address
        address: &sg_reg_battery_max_discharge_power 33047 # reg 33048
        input_type: holding
        data_type: uint16
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        scale: 10
        scan_interval: *scan_interval_fast

      # undocumented sensor (reverse engineered by some guys of photovoltaikforum.com and forum.iobroker.net )
      - name: Battery charging start power
        unique_id: sg_battery_charging_start_power
        device_address: !secret sungrow_modbus_device_address
        address: &sg_reg_battery_charging_start_power 33148 # reg 33149
        input_type: holding
        data_type: uint16
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        scale: 10
        scan_interval: *scan_interval_fast

      # undocumented sensor (reverse engineered by some guys of photovoltaikforum.com and forum.iobroker.net )
      - name: Battery discharging start power
        unique_id: sg_battery_discharging_start_power
        device_address: !secret sungrow_modbus_device_address
        address: &sg_reg_battery_discharging_start_power 33149 # reg 33150
        input_type: holding
        data_type: uint16
        precision: 0
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        scale: 10
        scan_interval: *scan_interval_fast

      #####################
      # modbus switches
      #####################
    switches:
      # BUG: 2026-01-10. Deactivated for now, see issue #643
      # https://github.com/mkaiser/Sungrow-SHx-Inverter-Modbus-Home-Assistant/issues/643
      # - name: Forced Startup Under Low SoC Standby
      #   unique_id: sg_forced_startup_under_low_soc_standby_switch
      #   slave: !secret sungrow_modbus_device_address
      #   address: *sg_reg_forced_startup_low_soc
      #   write_type: holding
      #   command_on: 0xAA
      #   command_off: 0x55
      #   verify:
      #     input_type: holding
      #     address: *sg_reg_forced_startup_low_soc
      #     state_on: 0xAA
      #     state_off: 0x55
      #     delay: 1

      - name: Backup Mode
        unique_id: sg_backup_mode_switch
        slave: !secret sungrow_modbus_device_address
        address: *sg_reg_backup_mode
        write_type: holding
        command_on: 0xAA
        command_off: 0x55
        verify:
          input_type: holding
          address: *sg_reg_backup_mode
          state_on: 0xAA
          state_off: 0x55
          delay: 1

      - name: Export power limit
        unique_id: sg_export_power_limit_switch
        slave: !secret sungrow_modbus_device_address
        address: *sg_reg_export_power_limit_mode
        write_type: holding
        command_on: 0xAA
        command_off: 0x55
        verify:
          input_type: holding
          address: *sg_reg_export_power_limit_mode
          state_on: 0xAA
          state_off: 0x55
          delay: 1

      - name: Load adjustment mode
        unique_id: sg_load_adjustment_mode_switch
        slave: !secret sungrow_modbus_device_address
        address: *sg_reg_load_adjustment_mode_enable
        write_type: holding
        command_on: 0xAA
        command_off: 0x55
        verify:
          input_type: holding
          address: *sg_reg_load_adjustment_mode_enable
          state_on: 0xAA
          state_off: 0x55
          delay: 1

sensor:
  - platform: filter
    name: "Daily consumed energy (filtered)"
    entity_id: sensor.daily_consumed_energy
    unique_id: sg_daily_consumed_energy_filtered
    filters:
      - filter: time_simple_moving_average
        window_size: "00:05"
        precision: 2

template:
  ###########################
  # template: binary sensor
  ###########################
  - binary_sensor:
      # bit 0 — PV generating
      - name: PV generating
        unique_id: sg_pv_generating
        availability: "{{ states('sensor.power_flow_status') not in ['unknown','unavailable'] }}"
        state: "{{ states('sensor.power_flow_status')|int |bitwise_and(0x1) }}"

      - name: PV generating (delay)
        unique_id: sg_pv_generating_delay
        availability: "{{ states('binary_sensor.pv_generating') not in ['unknown','unavailable'] }}"
        delay_on:
          seconds: 60
        state: "{{ states('binary_sensor.pv_generating') }}"

      # bit 1 — Battery charging
      - name: Battery charging
        unique_id: sg_battery_charging
        availability: "{{ states('sensor.power_flow_status') not in ['unknown','unavailable'] }}"
        state: "{{ states('sensor.power_flow_status')|int |bitwise_and(0x2) }}"

      - name: Battery charging (delay)
        unique_id: sg_battery_charging_delay
        availability: "{{ states('binary_sensor.battery_charging') not in ['unknown','unavailable'] }}"
        delay_on:
          seconds: 60
        state: "{{ states('binary_sensor.battery_charging') }}"

      # bit 2 — Battery discharging
      - name: Battery discharging
        unique_id: sg_battery_discharging
        availability: "{{ states('sensor.power_flow_status') not in ['unknown','unavailable'] }}"
        state: "{{ states('sensor.power_flow_status')|int |bitwise_and(0x4) }}"

      - name: Battery discharging (delay)
        unique_id: sg_battery_discharging_delay
        availability: "{{ states('binary_sensor.battery_discharging') not in ['unknown','unavailable'] }}"
        delay_on:
          seconds: 60
        state: "{{ states('binary_sensor.battery_discharging') }}"

      # bit 3 — Positive Load Power
      - name: Positive Load Power
        unique_id: sg_positive_load_power
        availability: "{{ states('sensor.power_flow_status') not in ['unknown','unavailable'] }}"
        state: "{{ states('sensor.power_flow_status')|int |bitwise_and(0x8) }}"

      - name: Positive Load Power (delay)
        unique_id: sg_positive_load_power_delay
        availability: "{{ states('binary_sensor.positive_load_power') not in ['unknown','unavailable'] }}"
        delay_on:
          seconds: 60
        state: "{{ states('binary_sensor.positive_load_power') }}"

      # bit 4 modbus spec "feed-in power"
      - name: Exporting Power
        unique_id: sg_exporting_power
        availability: "{{ states('sensor.power_flow_status') not in ['unknown','unavailable'] }}"
        state: "{{ states('sensor.power_flow_status')|int |bitwise_and(0x10) }}"

      - name: Exporting Power (delay)
        unique_id: sg_exporting_power_delay
        availability: "{{ states('binary_sensor.exporting_power') not in ['unknown','unavailable'] }}"
        delay_on:
          seconds: 60
        state: "{{ states('binary_sensor.exporting_power') }}"

      # bit 5 modbus spec "import power from grid"
      - name: Importing Power
        unique_id: sg_importing_power
        availability: "{{ states('sensor.power_flow_status') not in ['unknown','unavailable'] }}"
        state: "{{ states('sensor.power_flow_status')|int |bitwise_and(0x20) }}"

      - name: Importing Power (delay)
        unique_id: sg_importing_power_delay
        availability: "{{ states('binary_sensor.importing_power') not in ['unknown','unavailable'] }}"
        delay_on:
          seconds: 60
        state: "{{ states('binary_sensor.importing_power') }}"

      # bit 6 is reserved

      # bit 7 — Negative load power
      - name: Negative Load Power
        unique_id: sg_negative_load_power
        availability: "{{ states('sensor.power_flow_status') not in ['unknown','unavailable'] }}"
        state: "{{ states('sensor.power_flow_status')|int |bitwise_and(0x80) }}"

      - name: Negative Load Power (delay)
        unique_id: sg_negative_load_power_delay
        availability: "{{ states('binary_sensor.negative_load_power') not in ['unknown','unavailable'] }}"
        delay_on:
          seconds: 60
        state: "{{ states('binary_sensor.negative_load_power') }}"

  ####################
  # template: number
  ####################
  - number:
      - name: Battery Min Soc
        unique_id: uid_battery_min_soc
        unit_of_measurement: "%"
        min: 0
        max: 50 # max value is defined by modbus spec
        step: 1
        availability: "{{ states('sensor.battery_min_soc') | is_number }}"
        # modbus --> UI
        state: "{{ states('sensor.battery_min_soc') }}"
        # UI --> modbus
        set_value:
          - action: modbus.write_register
            data_template:
              hub: *sg_hub_name
              slave: !secret sungrow_modbus_device_address
              address: *sg_reg_min_soc
              value: "{{ value | int *10 }}"
          # manually refresh modbus register
          - action: homeassistant.update_entity
            target:
              entity_id: sensor.battery_min_soc

      - name: Battery Max Soc
        unique_id: uid_battery_max_soc
        unit_of_measurement: "%"
        min: 50 # min value is defined by modbus spec
        max: 100
        step: 1
        availability: "{{ states('sensor.battery_max_soc') | is_number }}"
        # modbus --> UI
        state: "{{ states('sensor.battery_max_soc') }}"
        # UI --> modbus
        set_value:
          - action: modbus.write_register
            data_template:
              hub: *sg_hub_name
              slave: !secret sungrow_modbus_device_address
              address: *sg_reg_max_soc
              value: "{{ value | int *10 }}"
          # manually refresh modbus register
          - action: homeassistant.update_entity
            target:
              entity_id: sensor.battery_max_soc

      - name: Battery Reserved SoC for Backup
        unique_id: uid_battery_reserved_soc_for_backup
        unit_of_measurement: "%"
        min: 0
        max: 100
        step: 1
        availability: "{{ states('sensor.battery_reserved_soc_for_backup') | is_number }}"
        # modbus --> UI
        state: "{{ states('sensor.battery_reserved_soc_for_backup') }}"
        # UI --> modbus
        set_value:
          - action: modbus.write_register
            data_template:
              hub: *sg_hub_name
              slave: !secret sungrow_modbus_device_address
              address: *sg_reg_reserved_soc_backup
              value: "{{ value | int }}"
          # manually refresh modbus register
          - action: homeassistant.update_entity
            target:
              entity_id: sensor.battery_reserved_soc_for_backup

      # This threshold is compared against the currently achievable charging power, not just against the currently available surplus.
      # If this is set higher than the maximum charging power of the battery, charging will not start.
      # If currently achievable charging power drops below this threshold, charging will stop. Actual charging power (limited by register 33047) is ignored.
      # Charging might stop before reaching 100% if set too close to the maximum charging power of the battery, due to achievable charging power naturally dropping at high state of charge.
      # set_sg_battery_charging_start_power:
      - name: Battery charging start power
        unique_id: uid_battery_charging_start_power
        unit_of_measurement: W
        min: 0
        max: 1000
        # The charging and the discharging options are meant to save the battery from frequent cycling between
        # charging and discharging. I am pretty confident, that a max: value for the number is ok with 1000W.
        # Please open an issue, if other values are needed.
        step: 10
        availability: "{{ states('sensor.battery_charging_start_power') | is_number }}"
        # modbus --> UI
        state: "{{ states('sensor.battery_charging_start_power') }}"
        # UI --> modbus
        set_value:
          - action: modbus.write_register
            data_template:
              hub: *sg_hub_name
              slave: !secret sungrow_modbus_device_address
              address: *sg_reg_battery_charging_start_power
              value: "{{ value | float /10 }}"
          # manually refresh modbus register
          - action: homeassistant.update_entity
            target:
              entity_id: sensor.battery_charging_start_power

      - name: Battery discharging start power
        unique_id: uid_battery_discharging_start_power
        unit_of_measurement: W
        min: 0
        max: 1000
        # The charging and the discharging options are meant to save the battery from frequent cycling between
        # charging and discharging. I am pretty confident, that a max: value for the number is ok with 1000W
        # Please open an issue, if other values are needed.
        step: 10
        availability: "{{ states('sensor.battery_discharging_start_power') | is_number }}"
        # modbus --> UI
        state: "{{ states('sensor.battery_discharging_start_power') }}"
        # UI --> modbus
        set_value:
          - action: modbus.write_register
            data_template:
              hub: *sg_hub_name
              slave: !secret sungrow_modbus_device_address
              address: *sg_reg_battery_discharging_start_power
              value: "{{ value | float /10 |int}}"
          # manually refresh modbus register
          - action: homeassistant.update_entity
            target:
              entity_id: sensor.battery_discharging_start_power

      - name: Battery forced charge discharge power
        unique_id: uid_battery_forced_charge_discharge_power
        unit_of_measurement: W
        min: 0
        max: !secret sungrow_modbus_battery_max_power
        step: 100
        availability: "{{ states('sensor.battery_forced_charge_discharge_power') | is_number }}"
        # modbus --> UI
        state: "{{ states('sensor.battery_forced_charge_discharge_power') }}"
        # UI --> modbus
        set_value:
          - action: modbus.write_register
            data_template:
              hub: *sg_hub_name
              slave: !secret sungrow_modbus_device_address
              address: *sg_reg_battery_forced_charge_discharge_power
              value: "{{ value | int }}"
          # manually refresh modbus register
          - action: homeassistant.update_entity
            target:
              entity_id: sensor.battery_forced_charge_discharge_power

      - name: Battery max charge power
        unique_id: uid_battery_max_charge_power
        unit_of_measurement: W
        min: 10 # 10W minimum defined in datasheet: 0.01 kW
        max: !secret sungrow_modbus_battery_max_power
        step: 100
        availability: "{{ states('sensor.battery_max_charge_power') | is_number }}"
        # modbus --> UI
        state: "{{ states('sensor.battery_max_charge_power') }}"
        # UI --> modbus
        set_value:
          - action: modbus.write_register
            data_template:
              hub: *sg_hub_name
              slave: !secret sungrow_modbus_device_address
              address: *sg_reg_battery_max_charge_power
              value: "{{ value | float / 10 | int}}"
          # manually refresh modbus register
          - action: homeassistant.update_entity
            target:
              entity_id: sensor.battery_max_charge_power

      - name: Battery max discharge power
        unique_id: uid_battery_max_discharge_power
        unit_of_measurement: W
        min: 10 # 10W minimum defined in datasheet: 0.01 kW
        max: !secret sungrow_modbus_battery_max_power
        step: 100
        availability: "{{ states('sensor.battery_max_discharge_power') | is_number }}"
        # modbus --> UI
        state: "{{ states('sensor.battery_max_discharge_power') }}"
        # UI --> modbus
        set_value:
          - action: modbus.write_register
            data_template:
              hub: *sg_hub_name
              slave: !secret sungrow_modbus_device_address
              address: *sg_reg_battery_max_discharge_power
              value: "{{ value| float / 10 | int}}"
          # manually refresh modbus register
          - action: homeassistant.update_entity
            target:
              entity_id: sensor.battery_max_discharge_power

      - name: Export power limit
        unique_id: uid_export_power_limit
        unit_of_measurement: W
        min: 0
        max: "{{ states('sensor.inverter_rated_output') }}"
        step: 100
        availability: "{{ states('sensor.export_power_limit')|is_number and states('sensor.inverter_rated_output')|is_number }}"
        # modbus --> UI
        state: "{{ states('sensor.export_power_limit') }}"
        # UI --> modbus
        set_value:
          - action: modbus.write_register
            data_template:
              hub: *sg_hub_name
              slave: !secret sungrow_modbus_device_address
              address: *sg_reg_export_power_limit
              value: >-
                {% set dev = states('sensor.sungrow_device_type') %}
                {% if dev.startswith('SH') and 'RT' in dev %}
                  {# SH*RT* devices (e.g. SH10RT, SH8.0RT-20, SH8.0RT-V112 or SH10RT-V122) #}
                  {{ (value | float / 10) | int }}
                {% elif dev.startswith('SH') and 'RS' in dev %}
                  {# SH*RS* devices (e.g. SH10RS) #}
                  {{ (value | float / 10) | int }}
                {% else %}
                  {{ value | int }}
                {% endif %}
          # manually refresh modbus register
          - action: homeassistant.update_entity
            target:
              entity_id: sensor.export_power_limit

  ####################
  # template: sensor
  ####################
  - sensor:
      - name: MPPT1 power
        unique_id: sg_mppt1_power
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        availability: "{{ states('sensor.mppt1_voltage')|is_number and states('sensor.mppt1_current')|is_number }}"
        state: "{{ (states('sensor.mppt1_voltage') | float * states('sensor.mppt1_current') | float) |int }}"

      - name: MPPT2 power
        unique_id: sg_mppt2_power
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        availability: "{{ states('sensor.mppt2_voltage')|is_number and states('sensor.mppt2_current')|is_number }}"
        state: "{{ (states('sensor.mppt2_voltage') | float * states('sensor.mppt2_current') | float) |int }}"

        # only for SH*T inverters with 3 MPPTs
      - name: MPPT3 power
        unique_id: uid_sg_mppt3_power
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        availability: "{{ states('sensor.mppt3_voltage')|is_number and states('sensor.mppt3_current')|is_number }}"
        state: "{{ (states('sensor.mppt3_voltage') | float * states('sensor.mppt3_current') | float) |int }}"

        # only for inverters with 4 MPPTs (SH8|10RS)
      - name: MPPT4 power
        unique_id: uid_sg_mppt4_power
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        availability: "{{ states('sensor.mppt4_voltage')|is_number and states('sensor.mppt4_current')|is_number }}"
        state: "{{ (states('sensor.mppt4_voltage') | float * states('sensor.mppt4_current') | float) |int }}"

      - name: Phase A power
        unique_id: sg_phase_a_power
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        availability: "{{ states('sensor.phase_a_voltage')|is_number and states('sensor.phase_a_current')|is_number }}"
        state: "{{ (states('sensor.phase_a_voltage') | float * states('sensor.phase_a_current') | float) |int }}"

      - name: Phase B power
        unique_id: sg_phase_b_power
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        availability: "{{ states('sensor.phase_b_voltage')|is_number and states('sensor.phase_b_current')|is_number }}"
        state: "{{ (states('sensor.phase_b_voltage') | float * states('sensor.phase_b_current') | float) |int }}"

      - name: Phase C power
        unique_id: sg_phase_c_power
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        availability: "{{ states('sensor.phase_c_voltage')|is_number and states('sensor.phase_c_current')|is_number }}"
        state: "{{ (states('sensor.phase_c_voltage') | float * states('sensor.phase_c_current') | float) |int }}"

      - name: Sungrow inverter state
        unique_id: sg_inverter_state
        device_class: enum
        availability: "{{ states('sensor.running_state_raw') not in ['unknown','unavailable'] }}"
        state: >-
          {% set invState=states('sensor.running_state_raw')|int %}
          {% set map = {
            0x0000: 'Running',
            0x0001: 'Stop',
            0x0002: 'Key stop',
            0x0004: 'Emergency Stop',
            0x0008: 'Standby',
            0x0020: 'Starting',
            0x0010: 'Initial standby',
            0x0014: 'Microgrid Operation',
            0x0040: 'Running',
            0x0041: 'Off-grid Charge',
            0x0080: 'Derating Running',
            0x0100: 'Fault',
            0x0200: 'Update Failed',
            0x0400: 'Running in maintain mode',
            0x0800: 'Running in compulsory (forced) mode',
            0x1000: 'Running (off-grid)',
            0x1111: 'Uninitialized',
            0x1200: 'Initial standby',
            0x1300: 'Key stop',
            0x1400: 'Standby',
            0x1500: 'Emergency Stop',
            0x1600: 'Starting',
            0x1700: 'AFCI self-test shutdown',
            0x1800: 'Intelligent Station Building Status',
            0x1900: 'Safe Mode',
            0x2000: 'Open loop',
            0x2500: 'Communicate fault',
            0x2501: 'Restarting',
            0x4000: 'Running in External EMS mode',
            0x4001: 'Emergency Charging Operation',
            0x8000: 'Stop',
            0x5500: 'Fault',
            0x8100: 'Derating Running',
            0x8200: 'Dispatch Running',
            0x9100: 'Warn Running',
          } %}
          {{ map.get(invState, 'Unknown running state code: 0x%04X' % invState) }}

      - name: Sungrow device type
        unique_id: sg_device_type
        availability: "{{ states('sensor.sungrow_device_type_code') not in ['unknown','unavailable'] }}"
        device_class: enum
        state: >-
          {% set devType=states('sensor.sungrow_device_type_code')|int %}
          {% set map = {
            0x0D06: 'SH3K6',
            0x0D07: 'SH4K6',
            0x0D09: 'SH5K-20',
            0x0D03: 'SH5K-V13',
            0x0D0A: 'SH3K6-30',
            0x0D0B: 'SH4K6-30',
            0x0D0C: 'SH5K-30',
            0x0D17: 'SH3.0RS',
            0x0D0D: 'SH3.6RS',
            0x0D18: 'SH4.0RS',
            0x0D0F: 'SH5.0RS',
            0x0D10: 'SH6.0RS',
            0x0D1A: 'SH8.0RS',
            0x0D1B: 'SH10RS',
            0x0E00: 'SH5.0RT',
            0x0E01: 'SH6.0RT',
            0x0E02: 'SH8.0RT',
            0x0E03: 'SH10RT',
            0x0E10: 'SH5.0RT-20',
            0x0E11: 'SH6.0RT-20',
            0x0E12: 'SH8.0RT-20',
            0x0E13: 'SH10RT-20',
            0x0E0C: 'SH5.0RT-V112',
            0x0E0D: 'SH6.0RT-V112',
            0x0E0E: 'SH8.0RT-V112',
            0x0E0F: 'SH10RT-V112',
            0x0E08: 'SH5.0RT-V122',
            0x0E09: 'SH6.0RT-V122',
            0x0E0A: 'SH8.0RT-V122',
            0x0E0B: 'SH10RT-V122',
            0x0E20: 'SH5T',
            0x0E21: 'SH6T',
            0x0E22: 'SH8T',
            0x0E23: 'SH10T',
            0x0E24: 'SH12T',
            0x0E25: 'SH15T',
            0x0E26: 'SH20T',
            0x0E28: 'SH25T',
            0x0D27: 'MG5RL',
            0x0D28: 'MG6RL'
          } %}
          {{ map.get(devType, 'Unknown device code: 0x%04X' % devType) }}

      # positive if charging, negative if discharging
      - name: Battery charging power signed
        unique_id: sg_battery_charging_power_signed
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        availability: "{{ states('sensor.battery_power') not in ['unknown','unavailable'] }}"
        state: "{{ states('sensor.battery_power')|int *-1}}" # sensor.battery_power is negative when charging

      # positive if charging else zero
      - name: Battery charging power
        unique_id: sg_battery_charging_power
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        availability: "{{ states('sensor.battery_charging_power_signed') not in ['unknown','unavailable'] }}"
        state: >-
          {% if states('sensor.battery_charging_power_signed') |int > 0 %}
            {{ states('sensor.battery_charging_power_signed') |int}}
          {% else %}
            0
          {% endif %}

      # NOTE:
      # Use this sensor for the HA energy dashboard.
      # HA Energy Dashboard configuration description:
      # "Pick a sensor which measures the electricity flowing into and out of the battery in either of GW, kW, MW, mW, TW, W.
      # Positive values indicate discharging the battery, negative values indicate charging the battery."
      #
      # positive if discharging, negative if charging
      - name: Battery discharging power signed
        unique_id: sg_battery_discharging_power_signed
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        availability: "{{ states('sensor.battery_power') not in ['unknown','unavailable'] }}"
        state: "{{ states('sensor.battery_power')|int}}" # sensor.battery_power is positive when discharging

      # positive if discharging else zero
      - name: Battery discharging power
        unique_id: sg_battery_discharging_power
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        availability: "{{ states('sensor.battery_discharging_power_signed') not in ['unknown','unavailable'] }}"
        state: >-
          {% if states('sensor.battery_discharging_power_signed')|int > 0 %}
            {{ states('sensor.battery_discharging_power_signed')|int }}
          {% else %}
            0
          {% endif %}

      # power from grid: positive if importing, else zero
      - name: Import power
        unique_id: sg_import_power
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        availability: "{{ states('sensor.export_power_raw') |is_number }}"
        state: >-
          {% if states('sensor.export_power_raw')|int < 0 %}
            {{ states('sensor.export_power_raw')|int *-1 }}
          {% else %}
            0
          {% endif %}

      # power to grid: positive if exporting, else zero
      - name: Export power
        unique_id: sg_export_power
        unit_of_measurement: W
        device_class: power
        state_class: measurement
        availability: "{{ states('sensor.export_power_raw') |is_number }}"
        state: >-
          {% if states('sensor.export_power_raw')|int > 0 %}
            {{ states('sensor.export_power_raw') }}
          {% else %}
            0
          {% endif %}

      # If min_soc is set to 15 and max soc is set to 90,
      # this "nominal battery level" will be between 15% and 90%
      # while the "battery level" is between 0 and 100%
      - name: "Battery level (nominal)"
        unique_id: sg_battery_level_nom
        unit_of_measurement: "%"
        device_class: battery
        state_class: measurement
        availability: >-
          {{ states('sensor.battery_level') not in ['unknown','unavailable'] 
          and states('sensor.battery_min_soc') not in ['unknown','unavailable'] 
          and states('sensor.battery_max_soc') not in ['unknown','unavailable'] }}
        state: >-
          {% set soc_min = states('sensor.battery_min_soc') | float %}
          {% set soc_max = states('sensor.battery_max_soc') | float %}
          {% set soc_cur = states('sensor.battery_level') | float %}
          {{
            (soc_min + ((soc_max - soc_min) * (soc_cur / 100))) | round(1)
          }}

      # If min_soc is set to 15 and max soc is set to 90,
      # this "nominal battery charge" will be between 15% and 90% of the capacity value,
      # reflecting the limits set by min_soc and max_soc
      - name: "Battery charge (nominal)"
        unique_id: sg_battery_charge_nom
        unit_of_measurement: kWh
        device_class: energy_storage
        state_class: measurement
        availability: >-
          {{ states('sensor.battery_capacity_high_precision') not in ['unknown','unavailable'] 
          and states('sensor.battery_level_nominal') not in ['unknown','unavailable'] }}
        state: >-
          {{
            ( states('sensor.battery_capacity_high_precision') | float *
            states('sensor.battery_level_nominal') | float / 100 )| round(1)
          }}

      # this is the actually **usable energy ** of the battery
      # with respect to min/ max soc, but WITHOUT the battery health.
      # If min_soc is set to 15 and max soc is set to 90,
      # this value is 0.75 * capacity
      - name: "Battery charge"
        unique_id: sg_battery_charge
        unit_of_measurement: kWh
        device_class: energy_storage
        state_class: measurement
        availability: >-
          {{ states('sensor.battery_capacity_high_precision') not in ['unknown','unavailable'] 
          and states('sensor.battery_level') not in ['unknown','unavailable'] 
          and states('sensor.battery_min_soc') not in ['unknown','unavailable']
          and states('sensor.battery_max_soc') not in ['unknown','unavailable'] }}
        state: >-
          {{ 
            ( states('sensor.battery_capacity_high_precision')|float 
            * ( states('sensor.battery_max_soc')|float - states('sensor.battery_min_soc')|float ) /100 
            * states('sensor.battery_level')|float /100 
            ) |round(2)
          }}

      # this is the actually **usable energy ** of the battery
      # with respect to min/ max soc, including the battery health.
      # This value is determined by multiplying Battery charge
      # with the health factor (battery_health), which is often a value
      # starting at 100 and decreases over time. Mine is 98% after 2 years.
      - name: "Battery charge (health-rated)"
        unique_id: sg_battery_charge_health_rated
        unit_of_measurement: kWh
        device_class: energy_storage
        state_class: measurement
        availability: >-
          {{ states('sensor.battery_charge') not in ['unknown','unavailable'] 
          and states('sensor.battery_state_of_health') not in ['unknown','unavailable'] }}
        state: >-
          {{ 
            ( states('sensor.battery_charge')|float 
            * states('sensor.battery_state_of_health')|float / 100 
            ) |round(2)
          }}

      - name: Daily consumed energy
        unique_id: sg_daily_consumed_energy
        unit_of_measurement: kWh
        device_class: energy
        # the state class is not total_increasing, because sometimes the read value are read at different times,
        # resulting in decreasing values.
        # "measurement" does not work, because it is incompatible with "energy"
        state_class: total
        availability: >-
          {{ states('sensor.daily_pv_generation') not in ['unknown','unavailable'] 
          and states('sensor.daily_exported_energy') not in ['unknown','unavailable'] 
          and states('sensor.daily_imported_energy') not in ['unknown','unavailable']
          and states('sensor.daily_battery_charge') not in ['unknown','unavailable']
          and states('sensor.daily_battery_discharge') not in ['unknown','unavailable'] }}
        state: >-
          {{ 
            (
              states('sensor.daily_pv_generation')|float 
              - states('sensor.daily_exported_energy')|float 
              + states('sensor.daily_imported_energy')|float 
              - states('sensor.daily_battery_charge')|float 
              + states('sensor.daily_battery_discharge')|float
            ) 
          }}

      - name: Total consumed energy
        unique_id: sg_total_consumed_energy
        unit_of_measurement: kWh
        device_class: energy
        state_class: total
        availability: >-
          {{ states('sensor.total_pv_generation') not in ['unknown','unavailable'] 
          and states('sensor.total_exported_energy') not in ['unknown','unavailable'] 
          and states('sensor.total_imported_energy') not in ['unknown','unavailable']
          and states('sensor.total_battery_charge') not in ['unknown','unavailable']
          and states('sensor.total_battery_discharge') not in ['unknown','unavailable'] }}
        state: >-
          {{ 
            (
              states('sensor.total_pv_generation')|float 
              - states('sensor.total_exported_energy')|float 
              + states('sensor.total_imported_energy')|float 
              - states('sensor.total_battery_charge')|float 
              + states('sensor.total_battery_discharge')|float
            )
          }}

  ###################
  # template: switch
  ###################
  - switch:
      # this enables/disables the inverter state & EMS settings in the dashboard
      # hopefully this prevents accidentally setting values while browsing on the phone :)
      - name: Sungrow dashboard enable danger mode
        unique_id: uid_sungrow_dashboard_enable_danger_mode

  ###################
  # template: button
  ###################
  - button:
      - name: Start inverter
        unique_id: uid_start_inverter
        variables:
          sg_start: 0xCF
        press:
          - action: modbus.write_register
            data:
              hub: *sg_hub_name
              slave: !secret sungrow_modbus_device_address
              address: *sg_reg_running_state
              value: "{{ sg_start }}"

      - name: Stop inverter
        unique_id: uid_stop_inverter
        variables:
          sg_stop: 0xCE
        press:
          - action: modbus.write_register
            data:
              hub: *sg_hub_name
              slave: !secret sungrow_modbus_device_address
              address: *sg_reg_running_state
              value: "{{ sg_stop }}"

  ###################
  # template: select
  ###################
  - select:
      - name: EMS mode
        unique_id: uid_ems_mode
        variables:
          # map: option name to raw value
          map:
            "Self-consumption mode (default)": 0
            "Forced mode": 2 # datasheet now calls it "compulsory mode"
            "External EMS": 3
            "VPP": 4
            # rarely used and commented for simplicity
            # "Microgid" :8
          fallback: "Self-consumption mode (default)"
        options: "{{ map.keys() | list | tojson }}" # get option names from map keys
        availability: "{{ states('sensor.ems_mode_selection_raw') | is_number }}"
        # modbus --> UI (raw value --> option)
        state: >-
          {# workaround for limited jinja python skills to reverse-search the map #}
          {# create a mutable namespace with default fallback #}
          {% set ns = namespace(result=fallback) %}
          {% set regVal = states('sensor.ems_mode_selection_raw') | int %}
          {# search in map inverted #}
          {% for key, value in map.items() %}
            {% if value == regVal %}
              {% set ns.result = key %}
            {% endif %}
          {% endfor %}
          {# save as result and output variable#}
          {% set result = ns.result %}
          {{ result }}
        # UI --> modbus
        select_option:
          - action: modbus.write_register
            data_template:
              hub: *sg_hub_name
              slave: !secret sungrow_modbus_device_address
              address: *sg_reg_ems_mode_selection
              value: "{{ map.get(option, map.get('Self-consumption mode (default)', 0)) | int }}"
          - delay:
              milliseconds: 100
          - action: homeassistant.update_entity
            target:
              entity_id: sensor.ems_mode_selection_raw
          - action: homeassistant.update_entity
            target:
              entity_id: sensor.running_state_raw

      - name: Battery forced charge discharge
        unique_id: uid_battery_forced_charge_discharge
        variables:
          # map: option name to raw value
          map:
            "Stop (default)": 0xCC
            "Forced charge": 0xAA
            "Forced discharge": 0xBB
          fallback: "Stop (default)"
        options: "{{ map.keys() | list | tojson }}" # get option names from map keys
        availability: "{{ states('sensor.battery_forced_charge_discharge_cmd_raw') | is_number }}"
        # modbus --> UI (raw value --> option)
        state: >-
          {# workaround for limited jinja python skills to reverse-search the map #}
          {# create a mutable namespace with default fallback #}
          {% set ns = namespace(result=fallback) %}
          {% set regVal = states('sensor.battery_forced_charge_discharge_cmd_raw') | int %}
          {# search in map inverted #}
          {% for key, value in map.items() %}
            {% if value == regVal %}
              {% set ns.result = key %}
            {% endif %}
          {% endfor %}
          {# save as result and output variable#}
          {% set result = ns.result %}
          {{ result }}
        # UI --> modbus
        select_option:
          - action: modbus.write_register
            data_template:
              hub: *sg_hub_name
              slave: !secret sungrow_modbus_device_address
              address: *sg_reg_forced_charge_discharge_cmd_raw
              value: "{{ map.get(option, map.get('Stop (default)', 0)) }}"
          - delay:
              milliseconds: 100
          - action: homeassistant.update_entity
            target:
              entity_id: sensor.battery_forced_charge_discharge_cmd_raw
          - action: homeassistant.update_entity
            target:
              entity_id: sensor.running_state_raw

      - name: Load adjustment mode
        unique_id: uid_load_adjustment_mode
        variables:
          # map: option name to raw value
          map:
            "Timing": 0
            "ON/OFF": 1
            "Power optimization": 2
            "Disabled": 3
          fallback: "Disabled"
        options: "{{ map.keys() | list | tojson }}" # get option names from map keys
        availability: "{{ states('sensor.load_adjustment_mode_selection_raw') | is_number }}"
        # modbus --> UI (raw value --> option)
        state: >-
          {# workaround for limited jinja python skills to reverse-search the map #}
          {# create a mutable namespace with default fallback #}
          {% set ns = namespace(result=fallback) %}
          {% set regVal = states('sensor.load_adjustment_mode_selection_raw') | int %}
          {# search in map inverted #}
          {% for key, value in map.items() %}
            {% if value == regVal %}
              {% set ns.result = key %}
            {% endif %}
          {% endfor %}
          {# save as result and output variable#}
          {% set result = ns.result %}
          {{ result }}
        # UI --> modbus
        select_option:
          - action: modbus.write_register
            data_template:
              hub: *sg_hub_name
              slave: !secret sungrow_modbus_device_address
              address: *sg_reg_load_adjustment_mode_selection
              value: "{{ map.get(option, map.get('Disabled', 3)) }}"
          - delay:
              milliseconds: 100
          - action: homeassistant.update_entity
            target:
              entity_id: sensor.load_adjustment_mode_selection_raw

automation:
  - id: "automation_sungrow_enable_danger_mode_auto_reset"
    alias: "sungrow dashboard enable danger mode auto reset"
    description: "Auto resets the dashboard danger mode after some seconds"
    triggers:
      - platform: state
        entity_id:
          - switch.sungrow_dashboard_enable_danger_mode
    conditions: []
    # if the switch is enabled, disable it automatically after 60 seconds
    action:
      - choose:
          - conditions:
              - condition: state
                entity_id: switch.sungrow_dashboard_enable_danger_mode
                state: "on"
            sequence:
              - delay: "00:01:00" # delay 60 seconds
              - service: switch.turn_off
                target:
                  entity_id: switch.sungrow_dashboard_enable_danger_mode
    mode: restart # use restart to avoid warnings, when GUI is updated too often and the delay causes this automation to not finish before the next call

  - id: "automation_sungrow_max_export_scene_sets_rated_limit"
    alias: "sungrow max export scene sets rated limit"
    description: "When scenes with max export power are activated, set export limit to inverter rated output"
    triggers:
      - platform: event
        event_type: call_service
        event_data:
          domain: scene
          service: turn_on
          service_data:
            entity_id: scene.set_max_export_power
    conditions: []
    action:
      - service: number.set_value
        target:
          entity_id: number.export_power_limit
        data:
          value: "{{ states('sensor.inverter_rated_output') | int(0) }}"
    mode: single

  - id: "automation_sungrow_self_consumption_mode_max_battery_discharge_scene_sets_rated_limit"
    alias: "sungrow self consumption mode max battery discharge scene sets rated limit"
    description: "When scenes with max battery discharge are activated, set battery discharge limit to sungrow_modbus_battery_max_power defined in secret"
    triggers:
      - platform: event
        event_type: call_service
        event_data:
          domain: scene
          service: turn_on
          service_data:
            entity_id: scene.self_consumption_mode_max_battery_discharge
    conditions: []
    action:
      - service: number.set_value
        target:
          entity_id: number.battery_max_discharge_power
        data:
          value: !secret sungrow_modbus_battery_max_power
    mode: single

scene:
  - name: Self-Consumption Mode (max battery discharge)
    entities:
      select.ems_mode: "Self-consumption mode (default)"
      select.battery_forced_charge_discharge: "Stop (default)"
      # Scenes don't resolve secrets and don't render templates, so we can use neither a sensor nor a secret as the target state here.
      # Instead, turning on this scene triggers the automation automation_sungrow_self_consumption_mode_max_battery_discharge_scene_sets_rated_limit which uses the sungrow_modbus_battery_max_power secret

  - name: Self-Consumption Mode (no battery discharge)
    entities:
      select.ems_mode: "Self-consumption mode (default)"
      select.battery_forced_charge_discharge: "Stop (default)"
      number.battery_max_discharge_power: "10" # set to minimum to disable discharging

  - name: Zero Export Power
    entities:
      switch.export_power_limit: "on"
      number.export_power_limit: "0"

  - name: Max Export Power
    entities:
      switch.export_power_limit: "off"
      # scripts don't render templates :/
      # number.export_power_limit is set by an automation

  - name: Battery Bypass Mode
    entities:
      select.ems_mode: "Forced mode"
      select.battery_forced_charge_discharge: "Stop (default)"

  - name: Battery Forced Discharge
    entities:
      select.ems_mode: "Forced mode"
      select.battery_forced_charge_discharge: "Forced discharge"

  - name: Battery Forced Charge
    entities:
      select.ems_mode: "Forced mode"
      select.battery_forced_charge_discharge: "Forced charge"
      # BUG: 2026-01-10. Deactivated for now, see issue #643
      # https://github.com/mkaiser/Sungrow-SHx-Inverter-Modbus-Home-Assistant/issues/643
      # switch.forced_startup_under_low_soc_standby: "on" # in case inverter is in standby due to low soc
